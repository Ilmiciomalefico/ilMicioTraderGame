<body>

    <div id="start-screen">
        <div class="panel" style="max-width: 85%; pointer-events: auto; border-color: var(--gold);">
            <h1 style="color: var(--neon); margin-top: 0; letter-spacing: 3px;">üêà ilMicioTrader üöÄ</h1>
            <p style="color: var(--gold); font-size: 0.9rem; font-weight: bold;">OPEN-SOURCE EXPERIMENT v1.0</p>
            
            <div style="text-align: left; font-size: 0.85rem; line-height: 1.4; color: #cbd5e1; background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; margin: 15px 0;">
                <p><strong>üéß Realni trg:</strong> Povezani smo direktno na Bitget WS (1s) in REST API (1m). Kar vidi≈°, se dogaja v tem trenutku na Wall Streetu (ali v kleti nekega kita).</p>
                <p><strong>üí∞ Fake Money:</strong> Tvojih $10,000 je bolj fejk kot oglasi za huj≈°anje. Namen tega projekta je 100% izobra≈æevalen.</p>
                <p><strong>üéÅ Najino darilo:</strong> To je najin skupni "Open Source" projekt. Jaz sem dal logiko, ti vizijo (in maƒçje emojije). Uporabi to za uƒçenje RSI strategij, ne za finanƒçni samomor.</p>
                <p style="text-align: center; color: var(--red); font-weight: bold;">‚ö†Ô∏è OPOZORILO: Trading povzroƒça odvisnost in potenje dlani!</p>
            </div>

            <p id="status-text" style="color: var(--gray); font-style: italic;">ƒåakam na tvoj ukaz, kapitan...</p>
            <button class="trade-btn" style="width:100%; border-color: var(--neon); background: rgba(0,255,136,0.1);" onclick="startGame()">VSTOPI V MATRIX (START)</button>
        </div>
    </div>

    <div id="game-ui">
        <div class="stats-top panel">
            <div style="flex:1">
                <div id="balance">$10,000.00</div>
                <div id="xp-bar"><div id="xp-fill"></div></div>
                <div id="rank-text" style="font-size: 0.6rem; color: var(--gold);">RANK: BAJSO</div>
            </div>
            <div style="text-align: right; flex:1">
                <div id="btc-price" style="font-weight: bold; color: var(--neon);">--</div>
                <div id="pnl" style="font-size: 0.8rem;">P/L: $0.00</div>
            </div>
        </div>
        <div id="controls">
            <div id="rsi-container">
                <div id="rsi-value">RSI (1m): --</div>
                <canvas id="rsiCanvas"></canvas>
            </div>
            <div class="btn-row">
                <button id="btn-long" class="trade-btn" onclick="setMode('LONG')">LONG</button>
                <button id="btn-exit" class="trade-btn active-exit" onclick="setMode('EXIT')">EXIT</button>
                <button id="btn-short" class="trade-btn" onclick="setMode('SHORT')">SHORT</button>
            </div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const rsiCanvas = document.getElementById('rsiCanvas');
        const rsiCtx = rsiCanvas.getContext('2d');

        let width, height, points = [], rsiHistory = [], currentPrice = 0, catY = 0;
        let balance = 10000, pnl = 0, level = 1, leverage = 5, xp = 0, mode = 'EXIT';
        let isStarted = false, minuteBuffer = [], timer60 = 0, currentRSI = 50;

        async function fetchHistory() {
            try {
                const res = await fetch('https://api.bitget.com/api/v2/spot/market/candles?symbol=BTCUSDT&granularity=1m&limit=100');
                const json = await res.json();
                if (json.data) {
                    const closes = json.data.map(d => parseFloat(d[4])).reverse();
                    minuteBuffer = closes;
                    rsiHistory = [];
                    for (let i = 14; i < closes.length; i++) {
                        let gains = 0, losses = 0;
                        for (let j = i - 13; j <= i; j++) {
                            let diff = closes[j] - closes[j-1];
                            if (diff >= 0) gains += diff; else losses -= diff;
                        }
                        let rs = (gains / 14) / (Math.abs(losses / 14) || 1);
                        rsiHistory.push(100 - (100 / (1 + rs)));
                    }
                    currentPrice = closes[closes.length - 1];
                    for(let i=0; i<80; i++) points.push(currentPrice);
                    currentRSI = rsiHistory[rsiHistory.length - 1] || 50;
                }
            } catch (e) { console.error("History fail:", e); }
        }

        async function startGame() {
            const status = document.getElementById('status-text');
            status.innerText = "üêà Praskam podatke z Bitgeta...";
            await fetchHistory();
            status.innerText = "üöÄ Pripravljen na moon!";
            
            setTimeout(() => {
                document.getElementById('start-screen').style.display = 'none';
                document.getElementById('game-ui').style.display = 'block';
                resize();
                isStarted = true;
                initWS();
                render();
            }, 800);
        }

        function setMode(m) {
            mode = m;
            document.getElementById('btn-long').className = 'trade-btn' + (m === 'LONG' ? ' active-long' : '');
            document.getElementById('btn-short').className = 'trade-btn' + (m === 'SHORT' ? ' active-short' : '');
            document.getElementById('btn-exit').className = 'trade-btn' + (m === 'EXIT' ? ' active-exit' : '');
        }

        function initWS() {
            const ws = new WebSocket('wss://ws.bitget.com/v2/ws/public');
            ws.onopen = () => ws.send(JSON.stringify({"op":"subscribe","args":[{"instType":"SPOT","channel":"ticker","instId":"BTCUSDT"}]}));
            ws.onmessage = (e) => {
                const d = JSON.parse(e.data);
                if (d.data && d.data[0]) handleData(parseFloat(d.data[0].lastPr));
            };
            ws.onclose = () => { if(isStarted) setTimeout(initWS, 1000); };
        }

        function handleData(price) {
            if (!currentPrice) currentPrice = price;
            if (mode !== 'EXIT') {
                let change = (price - currentPrice) / currentPrice;
                pnl += (balance + pnl) * change * leverage * (mode === 'LONG' ? 1 : -1);
            }
            if (balance + pnl <= 0) { balance = 10000; pnl = 0; setMode('EXIT'); }
            currentPrice = price;
            points.push(price);
            if(points.length > 80) points.shift();
            timer60++;
            if (timer60 >= 60) {
                minuteBuffer.push(price);
                if (minuteBuffer.length > 15) {
                    let gains = 0, losses = 0;
                    const startIdx = minuteBuffer.length - 14;
                    for (let i = startIdx; i < minuteBuffer.length; i++) {
                        let diff = minuteBuffer[i] - minuteBuffer[i-1];
                        if (diff >= 0) gains += diff; else losses -= diff;
                    }
                    let rs = (gains/14) / (Math.abs(losses/14) || 1);
                    currentRSI = 100 - (100 / (1 + rs));
                    rsiHistory.push(currentRSI);
                    if(rsiHistory.length > 60) rsiHistory.shift();
                }
                if(minuteBuffer.length > 110) minuteBuffer.shift();
                timer60 = 0;
                xp += 10; if (xp > level * 100) { level++; xp = 0; leverage += 5; }
            }
            updateUI();
        }

        function updateUI() {
            document.getElementById('balance').innerText = "$" + (balance + pnl).toLocaleString(undefined,{minimumFractionDigits:2});
            document.getElementById('btc-price').innerText = currentPrice.toFixed(2);
            document.getElementById('pnl').innerText = `P/L: ${pnl>=0?"+":""}${pnl.toFixed(2)}`;
            document.getElementById('pnl').style.color = pnl >= 0 ? "#00ff88" : "#ff3366";
            document.getElementById('rsi-value').innerText = `RSI (1m): ${currentRSI.toFixed(1)}`;
            document.getElementById('xp-fill').style.width = (xp / (level * 100) * 100) + "%";
            document.getElementById('rank-text').innerText = `RANK: LVL ${level} | TICK: ${timer60}/60`;
        }

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            rsiCanvas.width = rsiCanvas.offsetWidth;
            rsiCanvas.height = rsiCanvas.offsetHeight;
        }
        window.onresize = resize;

        function drawRSI() {
            rsiCtx.clearRect(0, 0, rsiCanvas.width, rsiCanvas.height);
            rsiCtx.lineWidth = 1;
            [30, 50, 70].forEach(l => {
                let y = rsiCanvas.height - (l/100 * rsiCanvas.height);
                rsiCtx.strokeStyle = "rgba(255,255,255,0.15)";
                rsiCtx.setLineDash([5, 5]);
                rsiCtx.beginPath(); rsiCtx.moveTo(0, y); rsiCtx.lineTo(rsiCanvas.width, y); rsiCtx.stroke();
                rsiCtx.setLineDash([]);
            });
            if (rsiHistory.length > 2) {
                rsiCtx.beginPath(); rsiCtx.lineWidth = 3;
                rsiHistory.forEach((r, i) => {
                    let x = i * (rsiCanvas.width / (rsiHistory.length - 1));
                    let y = rsiCanvas.height - (r/100 * rsiCanvas.height);
                    rsiCtx.strokeStyle = r > 70 ? "#ff3366" : (r < 30 ? "#00ff88" : "#4285f4");
                    if(i===0) rsiCtx.moveTo(x, y); else rsiCtx.lineTo(x, y);
                });
                rsiCtx.stroke();
            }
        }

        function render() {
            if (!isStarted) return;
            ctx.fillStyle = "#050608"; ctx.fillRect(0, 0, width, height);
            drawRSI();
            if (points.length > 2) {
                const min = Math.min(...points), max = Math.max(...points), range = (max-min)||10;
                const getY = (p) => height/2.5 + (height/4) * (-(p - (min+max)/2) / (range/2));
                const spacing = width / 80;
                ctx.beginPath(); ctx.lineWidth = 4;
                ctx.strokeStyle = mode === 'EXIT' ? "#64748b" : (mode === 'LONG' ? "#00ff88" : "#ff3366");
                points.forEach((p, i) => {
                    if(i===0) ctx.moveTo(i*spacing, getY(p)); else ctx.lineTo(i*spacing, getY(p));
                });
                ctx.stroke();
                catY += (getY(points[points.length-1]) - catY) * 0.15;
                ctx.font = "32px Arial"; ctx.textAlign = "center";
                ctx.fillText(pnl > 0 ? "ü§ë" : "üê±", (points.length-1)*spacing, catY);
            }
            requestAnimationFrame(render);
        }
    </script>
</body>
